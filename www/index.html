<!--

	COORDINATE AXES: -> CANVAS
	(1) Display a scene with default coordinate axes, where each axis is colored 
	(x-axis in red, y-axis in green, z-axis in blue).

	LOAD MODEL AND MODEL CONTROLS: -> MODEL 
	(2) Load 3D models in glTF 2.0 format and position them in space 
	(with options for translation, rotation, and scaling).

	MODEL PROPERTIES: -> MODEL
	(3) Display model properties: number of vertices, number of indices, and the size of the bounding box.

	PROCEDURAL GEOMETRIES: -> PROCEDURAL GEOMETRY
	(4) Add procedurally generated objects (plane, cube, sphere, torus).

	CAMERA CONTROLS: -> CAMERAS
	(5) Allow camera position and rotation control using mouse or keyboard input, 
	with the ability to change the camera's focal point.

	LIGHTS: -> LIGHTS
	(6) Place point lights in the scene, with adjustable parameters for color, 
	intensity, and attenuation (constant, linear, quadratic attenuation).
	(7) Define the lighting model (Lambert and Phong) and shading parameters 
	(diffuse and specular color, shininess) for each object.

	FRAGMENT SHADER: ->
	(8) Implement per-fragment lighting and shading calculations.

	TEXTURES: -> MODEL.TEXTURES
	(9) Assign textures to each object individually, with options for 
	texture coordinate mapping (input file coordinates, planar mapping, 
	cylindrical mapping, spherical mapping), and allow translation, rotation, 
	scaling, and projection direction for UV coordinates.

	GLOBALS:
	(10) Provide a global setting to control texture wrapping modes (CLAMP_TO_EDGE, REPEAT, MIRRORED_REPEAT).
	(11) Provide a global setting to control texture filtering modes (NEAREST, LINEAR) and mipmapping options.
	(12) Allow global enabling and disabling of mipmaps.

-->

<!--
The normal way to use WebGL:

At init time
  > for each shader program
    1. create and compile vertex shader
    2. create and compile fragment shader
    3. create program, attach shaders, link program
  > for each model
    0. for each type of vertex data (positions, normal, color, texcoord
    1. create a buffer
    2. copy data to buffer
  > create textures

Then at render time
  > for each model
    1. use shader program appropriate for model
    2. bind buffers, enable and setup attributes
    3. bind textures and set uniforms
    4. call drawArrays or drawElements
-->

<!-- https://webgl2fundamentals.org/webgl/lessons/resources/webgl-state-diagram.html -->

<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>90 - Loading glTF files - ES6/WebGL 2.0 Examples</title>

  <link rel="stylesheet" type="text/css" href="./src/styles/style.css">

  <script type="importmap">
    {
      "imports": {
        "glMatrix": "./src/lib/glMatrix/index.js"
      }
    }
  </script>

  <script type="module" src="./index.js"></script>
</head>

<body>
  <div class="Fullscreen">
    <canvas id="mainCanvas"></canvas>
  </div>
  <div class="Logs">
    <span>
      [CAMERA POSITION:
      <span id="cameraPosition">X: 0, Y: 0, Z: 0</span>
      ]
    </span>
    <span>
      [CAMERA ROTATION:
      <span id="cameraRotation">Pitch: 0°, Yaw: 0°, Roll: 0°</span>
      ]
    </span>
    <span>
      [ANIMATION TIME:
      <span id="animationTime">0</span>
      seconds]
    </span>
  </div>
</body>

</html>